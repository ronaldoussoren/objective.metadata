"""
Tool for merging an excptions file and the information collected from
a number of sets of header files (various architectures and SDKs) into
the metadata source file used by PyObjC.

The metadata source file is a python file with a number of definitions
that are used by the lazy loading functionality.
"""
from __future__ import absolute_import

import collections
import itertools
import operator
import textwrap
import time

from .storage import load_framework_info


class MergeNeededException(Exception):
    pass


HEADER = textwrap.dedent(
    """\
    # This file is generated by objective.metadata
    #
    # Last update: %(timestamp)s

    import objc, sys

    if sys.maxsize > 2 ** 32:
        def sel32or64(a, b): return b
    else:
        def sel32or64(a, b): return a
    if sys.byteorder == 'little':
        def littleOrBig(a, b): return a
    else:
        def littleOrBig(a, b): return b

    misc = {
    }
"""
)

FOOTER = textwrap.dedent(
    """\

        # END OF FILE
"""
)


class BStr(str):
    def __repr__(self):
        return "b" + super(BStr, self).__repr__()


# noinspection PyProtectedMember
class UStr(object):
    def __init__(self, value):
        self._value = value

    def __repr__(self):
        value = self._value.encode("utf-8")
        return 'b%r.decode("utf-8")' % (value,)

    def __eq__(self, other):
        if not isinstance(other, UStr):
            raise TypeError((self, other))

        return self._value == other._value

    def __ne__(self, other):
        if not isinstance(other, UStr):
            raise TypeError((self, other))

        return self._value != other._value

    def __lt__(self, other):
        if not isinstance(other, UStr):
            raise TypeError((self, other))

        return self._value < other._value

    def __le__(self, other):
        if not isinstance(other, UStr):
            raise TypeError((self, other))

        return self._value <= other._value

    def __gt__(self, other):
        if not isinstance(other, UStr):
            raise TypeError((self, other))

        return self._value > other._value

    def __ge__(self, other):
        if not isinstance(other, UStr):
            raise TypeError((self, other))

        return self._value >= other._value

    def __hash__(self):
        return hash(self._value)


class WrappedCall(object):
    def __init__(self, name, args, kwds):
        self.name = name
        self.args = args
        self.kwds = kwds

    def __repr__(self):
        args = [repr(a) for a in self.args]
        for k, v in self.kwds.items():
            args.append("%s=%r" % (k, v))

        if args:
            return "%s(%s)" % (self.name, ", ".join(args))

    def _key(self):
        return (self.name, self.args, self.kwds)

    def __eq__(self, other):
        if not isinstance(other, WrappedCall):
            raise TypeError

        return self._key() == other._key()

    def __ne__(self, other):
        if not isinstance(other, WrappedCall):
            raise TypeError

        return self._key() != other._key()

    def __lt__(self, other):
        if not isinstance(other, WrappedCall):
            raise TypeError

        return self._key() < other._key()

    def __le__(self, other):
        if not isinstance(other, WrappedCall):
            raise TypeError

        return self._key() <= other._key()

    def __gt__(self, other):
        if not isinstance(other, WrappedCall):
            raise TypeError

        return self._key() > other._key()

    def __ge__(self, other):
        if not isinstance(other, WrappedCall):
            raise TypeError

        return self._key() >= other._key()

    def hash(self):
        return hash((self.name, self.args, self.kwds))


class FuncCall(object):
    def __init__(self, func_name):
        self._func_name = func_name

    def __call__(self, *args, **kwds):
        return WrappedCall(self._func_name, args, kwds)


sel32or64 = FuncCall("sel32or64")
littleOrBig = FuncCall("littleOrBig")


def _is_little_endian(archs):
    return archs in ({"i386"}, {"x86_64"}, {"i386", "x86_64"})


def _is_big_endian(archs):
    return archs in ({"ppc"}, {"ppc64"}, {"ppc", "ppc64"})


def _is_32_bit(archs):
    return archs in ({"ppc"}, {"i386"}, {"ppc", "i386"})


def _is_64_bit(archs):
    return archs in ({"ppc64"}, {"x86_64"}, {"ppc64", "x86_64"})


def classify_archs(archs1, archs2, value1, value2):
    if _is_32_bit(archs1) and _is_64_bit(archs2):
        return sel32or64(value1, value2)
    elif _is_32_bit(archs2) and _is_64_bit(archs1):
        return sel32or64(value2, value1)
    elif _is_little_endian(archs1) and _is_big_endian(archs2):
        return littleOrBig(value1, value2)
    elif _is_little_endian(archs2) and _is_big_endian(archs1):
        return littleOrBig(value2, value1)
    else:
        return None


def merge_defs(defs, key):
    # Uniq is logically a dict mapping from a value
    # to the set of architectures that use this value.
    # This cannot be a real dictionary because we sometimes
    # the values used are not hashable.
    uniq = []
    for d in defs:
        for k, v in uniq:
            if k == d[key]:
                v.add(d["arch"])
                break
        else:
            uniq.append((d[key], {d["arch"]}))

    if len(uniq) == 1:
        return {key: uniq[0][0]}

    elif len(uniq) == 2:
        value = classify_archs(uniq[0][1], uniq[1][1], uniq[0][0], uniq[1][0])
        if value is None:
            raise MergeNeededException("Merge needed %r" % (uniq,))

        return {key: value}

    else:
        raise MergeNeededException("Merge needed %r" % (uniq,))


def merge_definition_lists(defs):
    all_methods = {}
    for info in defs:
        arch = info["arch"]
        methods = info["methods"]
        for meth in methods:
            try:
                lst = all_methods[meth["selector"]]
            except KeyError:
                lst = all_methods[meth["selector"]] = []

            if "retval" in meth:
                typestr = meth["retval"]["typestr"]
            else:
                typestr = "v"
            typestr += "@:"
            for a in meth["args"]:
                typestr += a["typestr"]
            lst.append({"arch": arch, "typestr": typestr})

    result = []
    for selector, typestr in all_methods.items():
        for v in typestr:
            v["typestr"] = v["typestr"]
        typestr = merge_defs(typestr, "typestr")["typestr"]
        result.append(
            FuncCall("objc.selector")(None, BStr(selector), typestr, isRequired=False)
        )

    return result


def extract_informal_protocols(exceptions, headerinfo):
    found = {}

    excinfo = exceptions["definitions"].get("informal_protocols", {})
    for info in headerinfo:
        for name, value in info["definitions"].get("informal_protocols", {}).items():
            if name in excinfo:
                if excinfo[name].get("ignore", False):
                    continue

            if name not in found:
                found[name] = []

            found[name].append({"methods": value["methods"], "arch": info["arch"]})

    informal_protocol = FuncCall("objc.informal_protocol")
    selector = FuncCall("objc.selector")
    result = {}

    def calc_selector(meth):
        if "retval" in meth:
            typestr = meth["retval"]["typestr"]
        else:
            typestr = b"v"
        typestr += b"@:"
        for a in meth["args"]:
            typestr += a["typestr"]
        return selector(None, BStr(meth["selector"]), typestr, isRequired=False)

    for name in found:
        if len(found[name]) == 1:
            result[name] = informal_protocol(
                name, list(map(calc_selector, found[name][0]["methods"]))
            )

        else:
            merge_definition_lists(found[name])

            result[name] = informal_protocol(name, merge_definition_lists(found[name]))

    return result


def _cleanup_callable_metadata(metadata):
    def cleanup_type(rec):
        if "typestr" in rec:
            rec["type"] = rec["typestr"]
            del rec["typestr"]
        elif "type_override" in val:
            rec["type"] = rec["type_override"]
            del rec["type_override"]

        if isinstance(rec["type"], (list, tuple)):
            if isinstance(rec["type"][1], bool):
                # Correct scanner stores 'typestr_special' in wrong location
                rec["type"] = rec["type"][0]

        if isinstance(rec["type"], (list, tuple)):
            rec["type"] = sel32or64(*rec["type"])
        else:
            rec["type"] = rec["type"]
        return rec

    metadata["retval"] = cleanup_type(dict(metadata["retval"]))

    d = {}
    if "args" in metadata:
        if isinstance(metadata["args"], dict):
            metadata["args"] = [
                metadata["args"][x] for x in range(len(metadata["args"]))
            ]
        for k, val in enumerate(metadata["args"]):
            d[k] = cleanup_type(dict(val))

        metadata["arguments"] = d
        del metadata["args"]

    return metadata


def calc_func_proto(exc, info, arch):
    types = []
    metadata = {}

    if info.get("variadic"):
        metadata["variadic"] = info["variadic"]

    for k in exc:
        if k in ("args", "retval"):
            continue
        metadata[k] = exc[k]

    if "retval" in exc and "type_override" in exc["retval"]:
        t = exc["retval"]["type_override"]
        if isinstance(t, (list, tuple)):
            if arch in ("i386", "ppc"):
                types.append(t[0])
            else:
                types.append(t[1])
        else:
            types.append(t)
    elif "retval" in info and "typestr" in info["retval"]:
        types.append(info["retval"]["typestr"])
    else:
        types.append("v")

    retval = {}
    if "retval" in info:
        retval.update(info["retval"])
    if exc and "retval" in exc:
        retval.update(exc["retval"])
    if "typestr" in retval:
        del retval["typestr"]
    if "type_override" in retval:
        del retval["type_override"]
    if retval:
        metadata["retval"] = retval

    if "function" in retval:
        retval["callable"] = _cleanup_callable_metadata(dict(retval["function"]))
        del retval["function"]

    if "block" in retval:
        retval["block"] = _cleanup_callable_metadata(dict(retval["block"]))

    metadata["arguments"] = {}

    arg_info = info["args"]
    if isinstance(arg_info, dict):
        arg_info = [arg_info[i] for i in range(len(arg_info))]

    for idx, a in enumerate(arg_info):

        # C has 'aFunction(void)' as the function prototype for functions
        # without arguments.
        if a.get("name") is None and a.get("typestr") == "v":
            continue

        if "args" in exc and "type_override" in exc["args"].get(idx, {}):
            t = exc["args"][idx]["type_override"]
            if isinstance(t, (list, tuple)):
                if arch in ("i386", "ppc"):
                    types.append(t[0])
                else:
                    types.append(t[1])
            else:
                types.append(t)
        else:
            types.append(a["typestr"])

        arg = dict(a)
        if "args" in exc and idx in exc["args"]:
            arg.update(exc["args"][idx])
        if "name" in arg:
            del arg["name"]
        if "typestr" in arg:
            del arg["typestr"]
        if "type_override" in arg:
            del arg["type_override"]

        if "sel_of_type" in arg:
            v = arg["sel_of_type"]
            if isinstance(v, (list, tuple)):
                v = sel32or64(v[0], v[1])
            else:
                v = v
            arg["sel_of_type"] = v

        if "block" in arg:
            arg["block"] = _cleanup_callable_metadata(dict(arg["block"]))

        if "callable" in arg:
            arg["callable"] = _cleanup_callable_metadata(dict(arg["callable"]))

        if "function" in arg:
            arg["callable"] = _cleanup_callable_metadata(dict(arg["function"]))
            del arg["function"]
            print(arg["callable"])

        for k in arg:
            if isinstance(arg[k], list):
                arg[k] = tuple(arg[k])

        if arg:
            metadata["arguments"][idx] = arg

    if not metadata["arguments"]:
        del metadata["arguments"]

    return b"".join(types), metadata


def extract_functions(exceptions, headerinfo):
    functions = {}
    excinfo = exceptions["definitions"].get("functions", {})

    for info in headerinfo:
        for name, value in info["definitions"].get("functions", {}).items():
            if name in excinfo:
                if excinfo[name].get("ignore", False):
                    continue

            print(name)
            typestr, metadata = calc_func_proto(
                excinfo.get(name, {}), value, info["arch"]
            )
            value = {"typestr": typestr, "metadata": metadata, "arch": info["arch"]}

            try:
                functions[name].append(value)
            except KeyError:
                functions[name] = [value]

    for name, value in excinfo.items():
        if name in functions:
            continue
        if value.get("retval") and value.get("args") is not None:
            typestr, metadata = calc_func_proto(
                excinfo.get(name, {}), value, info["arch"]
            )
            value = {"typestr": typestr, "metadata": metadata, "arch": info["arch"]}
            functions[name] = [value]

    result = {}
    for idx, (name, value) in enumerate(sorted(functions.items())):
        try:
            info = merge_defs(value, "typestr")
        except BaseException:
            print("[%d/%d] %s" % (idx + 1, len(functions), name))
            raise
        if value[0]["metadata"]:
            result[name] = (info["typestr"], "", value[0]["metadata"])
        else:
            result[name] = (info["typestr"],)
    return result


def extract_opaque(exceptions):
    excinfo = exceptions["definitions"].get("opaque", {})

    opaque = {}
    create_pointer = FuncCall("objc.createOpaquePointerType")
    for name, info in excinfo.items():
        if "typestr" not in info:
            print("WARNING: Skip %r, no typestr found" % (name,))
            continue

        opaque[name] = create_pointer(name, info["typestr"])

    return opaque


def extract_opaque_cftypes(exceptions, headerinfo):
    cftypes = {}
    excinfo = exceptions["definitions"].get("cftypes", {})

    # This is a naive fix for some unclear code
    last_info_arch = None

    for info in headerinfo:
        for name, value in info["definitions"].get("cftypes", {}).items():
            if name in excinfo:
                if excinfo[name].get("ignore", False):
                    continue
                if not excinfo[name].get("opaque", False):
                    continue
            else:
                # Not in exception data, cannot be 'opaque pointer'
                continue

            try:
                lst = cftypes[name]
            except KeyError:
                lst = cftypes[name] = []

            lst.append({"typestr": value["typestr"], "arch": info["arch"]})
            last_info_arch = info["arch"]

    for name, value in excinfo.items():
        if name in cftypes:
            continue
        if "typestr" not in value:
            continue
        if "opaque" not in value:
            continue

        # Old code used info unassigned (or worse, left
        # over from the previous iteration)
        # cftypes[name] = [{'typestr': value['typestr'], 'arch': info['arch']}]
        cftypes[name] = [{"typestr": value["typestr"], "arch": last_info_arch}]

    result = {}
    create_pointer = FuncCall("objc.createOpaquePointerType")
    for name, values in sorted(cftypes.items()):
        typestr = merge_defs(values, "typestr")["typestr"]
        result[name] = create_pointer(name, typestr)

    return result


def extract_aliases(exceptions, headerinfo):
    aliases = {}
    excinfo = exceptions["definitions"].get("aliases", {})

    for info in headerinfo:
        for orig, alias in info["definitions"].get("aliases", {}).items():
            if orig in excinfo:
                if excinfo[orig].get("ignore", False):
                    continue
                v = excinfo[orig].get("alias")
                if v is not None:
                    alias = v

            try:
                lst = aliases[orig]
            except KeyError:
                lst = aliases[orig] = []

            lst.append({"alias": alias, "arch": info["arch"]})

    result = {}
    for name, values in sorted(aliases.items()):
        print(name)
        alias = merge_defs(values, "alias")["alias"]

        result[name] = alias

    for name, value in excinfo.items():
        if name in result:
            continue
        if "alias" not in value:
            continue
        if value.get("ignore", False):
            continue

        result[name] = value["alias"]

    return result


def extract_cftypes(exceptions, headerinfo):
    cftypes = {}
    excinfo = exceptions["definitions"].get("cftypes", {})

    for info in headerinfo:
        for name, value in info["definitions"].get("cftypes", {}).items():
            if name in excinfo:
                if excinfo[name].get("ignore", False):
                    continue
                if excinfo[name].get("opaque", False):
                    continue

            try:
                lst = cftypes[name]
            except KeyError:
                lst = cftypes[name] = []

            lst.append({"typestr": value["typestr"], "arch": info["arch"]})

    result = []
    for name, values in sorted(cftypes.items()):
        value = merge_defs(values, "typestr")
        exc = excinfo.get(name, {})

        result.append(
            (name, value["typestr"], exc.get("gettypeid_func"), exc.get("tollfree"))
        )

    for name, value in excinfo.items():
        if name in cftypes:
            continue
        if "typestr" not in value:
            continue
        if "opaque" in value:
            continue

        result.append(
            (name, value["typestr"], value.get("gettypeid_func"), value.get("tollfree"))
        )

    return result


def extract_expressions(exceptions, headerinfo):
    result = {}

    excinfo = exceptions["definitions"].get("expressions", {})

    # Add all definitions from parsed header files
    for info in headerinfo:
        for name, value in info["definitions"].get("expressions", {}).items():
            if name in excinfo:
                if excinfo[name].get("ignore", False):
                    continue

            if name in result:
                result[name].append({"value": value, "arch": info["arch"]})

            else:
                result[name] = [{"value": value, "arch": info["arch"]}]

    # Finally add definitions that were manually added to  the exceptions file
    for name in excinfo:
        if name not in result and "value" in excinfo[name]:
            result[name] = [{"typestr": excinfo[name]["value"], "arch": None}]

    for name in result:
        result[name] = merge_defs(result[name], "value")["value"]

    return result


def extract_externs(exceptions, headerinfo):
    result = {}

    excinfo = exceptions["definitions"].get("externs", {})

    # Add all definitions from parsed header files
    for info in headerinfo:
        for name, value in info["definitions"].get("externs", {}).items():
            if name in excinfo:
                if excinfo[name].get("ignore", False):
                    continue
                if excinfo[name].get("type_override"):
                    value[name] = {"typestr": excinfo[name]["type_override"]}
                    continue

            typestr = value["typestr"]
            if typestr == "^{__CFString}":
                typestr = "@"

            if name in result:
                result[name].append({"typestr": typestr, "arch": info["arch"]})

            else:
                result[name] = [{"typestr": typestr, "arch": info["arch"]}]

    # Finally add definitions that were manually added to  the exceptions file
    for name in excinfo:
        if excinfo[name].get("ignore", False):
            continue
        if name not in result and "type_override" in excinfo[name]:
            result[name] = [{"typestr": excinfo[name]["type_override"], "arch": None}]
        if name not in result and "typestr" in excinfo[name]:
            result[name] = [{"typestr": excinfo[name]["typestr"], "arch": None}]

    for name in result:
        result[name] = merge_defs(result[name], "typestr")
        if name in excinfo:
            if excinfo[name].get("magic_cookie", False):
                result[name]["magic_cookie"] = True

    return result


def extract_enums(exceptions, headerinfo):
    result = {}

    excinfo = exceptions["definitions"].get("enum", {})

    for info in headerinfo:
        for name, value in info["definitions"].get("enum", {}).items():
            if name in excinfo:
                if excinfo[name].get("ignore", False):
                    continue
                if excinfo[name].get("value"):
                    if isinstance(excinfo[name]["value"], str):
                        result[name] = [
                            {"value": BStr(excinfo[name]["value"]), "arch": None}
                        ]
                    else:
                        result[name] = [{"value": excinfo[name]["value"], "arch": None}]
                    continue

                if excinfo[name].get("type") == "unicode":
                    if name in result:
                        result[name].append({"value": chr(value), "arch": info["arch"]})

                    else:
                        result[name] = [{"value": chr(value), "arch": info["arch"]}]
                    continue

            if name in result:
                result[name].append({"value": value, "arch": info["arch"]})

            else:
                result[name] = [{"value": value, "arch": info["arch"]}]

    # Finally add definitions that were manually added to  the exceptions file
    for name in excinfo:
        if name not in result and "value" in excinfo[name]:
            result[name] = [{"value": excinfo[name]["value"], "arch": None}]

    for name in result:
        try:
            result[name] = merge_defs(result[name], "value")
        except MergeNeededException:
            print(name)

            if name.endswith("Count"):
                # A number of headers define a kFooCount value that is
                # the highest support value of a specific kind, use
                # the maximum value in those cases.
                result[name] = max(x["value"] for x in result[name])
            else:
                raise

    return result


def exception_method(exceptions, key):
    for m in exceptions.get(key[0], {"methods": ()}).get("methods", ()):
        if m["selector"] == key[1] and m["class_method"] == key[2]:
            return m
    return None


def merge_arginfo(current, update, arch, only_special):
    if "typestr_special" in update:
        if update["typestr_special"] or not only_special:
            if "type" not in current:
                current["type"] = collections.defaultdict(list)

            current["type"][update["typestr"]].append(arch)

    for k in update:
        if k not in ("typestr", "typestr_special"):
            current[k] = update[k]


def calc_type(choices):
    if isinstance(choices, str):
        # investigate why this is needed (Collabortation wrappers)
        return choices
    if len(choices) == 1:
        return BStr(next(iter(choices)))

    else:
        if isinstance(choices, list):
            return sel32or64(*[BStr(ch) for ch in choices])

        else:
            ch = []
            for k, v in choices.items():
                for e in v:
                    ch.append({"value": BStr(k), "arch": e})

            return merge_defs(ch, "value")["value"]


def merge_method_info(
    clsname, selector, class_method, infolist, exception, only_special
):
    """
    Merge method metadata and exceptions and return the resulting
    information dictionary. Returns ``None`` when there is no information
    that couldn't be loaded at runtime by the bridge.
    """
    result = {"arguments": {}}
    for info in infolist:
        for k in info:
            if k in ("class", "selector", "class_method", "arch"):
                continue

            elif k == "retval":
                if "retval" not in result:
                    result["retval"] = {}

                merge_arginfo(result["retval"], info[k], info["arch"], only_special)

            elif k == "args":
                for idx, value in enumerate(info[k]):
                    if idx + 2 not in result["arguments"]:
                        result["arguments"][idx + 2] = {}

                    merge_arginfo(
                        result["arguments"][idx + 2], value, info["arch"], only_special
                    )

            elif k == "visibility":
                pass

            else:
                # merge basic attributes, for now all entries
                # should have the same information.
                if k in result:
                    if result[k] != info[k]:
                        raise ValueError(k)
                else:
                    result[k] = info[k]

    if exception is not None:
        # Merge exception information
        for k in exception:
            if k in ("selector", "class_method"):
                continue

            if k == "retval":
                if "retval" in result:
                    result["retval"].update(exception[k])
                else:
                    result["retval"] = dict(exception[k])

                if "type_override" in result["retval"]:
                    result["retval"]["type"] = result["retval"]["type_override"]
                    del result["retval"]["type_override"]

            elif k == "args":
                args = result["arguments"]
                for idx, value in exception["args"].items():
                    if idx + 2 in args:
                        args[idx + 2].update(value)
                    else:
                        args[idx + 2] = dict(value)

                    if "type_override" in args[idx + 2]:
                        args[idx + 2]["type"] = args[idx + 2]["type_override"]
                        del args[idx + 2]["type_override"]

            else:
                result[k] = exception[k]

        for rec in itertools.chain(
            [result.get("retval", {})], result.get("arguments", {}).values()
        ):
            if "c_array_length_in_arg" in rec:
                v = rec["c_array_length_in_arg"]
                if isinstance(v, (list, tuple)):
                    input_thing, output_thing = v
                    input_thing += 2
                    output_thing += 2
                    v = input_thing, output_thing
                else:
                    v += 2
                rec["c_array_length_in_arg"] = v

            if "callable" in rec:

                def replace_typestr(val):
                    if "typestr" in val:
                        val["type"] = val["typestr"]
                        del val["typestr"]
                    for member in val.values():
                        if isinstance(member, dict):
                            replace_typestr(member)

                replace_typestr(rec["callable"])

    if "retval" in result:
        if "type" in result["retval"]:
            result["retval"]["type"] = calc_type(result["retval"]["type"])

        for k in ("type_modifier", "sel_of_type"):
            if k in result["retval"]:
                result["retval"][k] = result["retval"][k]

        if "callable" in result["retval"]:
            this_callable = result["retval"]["callable"]
            for value in itertools.chain(
                [this_callable.get("retval", {})],
                this_callable.get("arguments", {}).values(),
            ):
                if isinstance(value["type"], str):
                    value["type"] = value["type"]
                else:
                    value["type"] = sel32or64(value["type"][0], value["type"][1])

        if not result["retval"]:
            del result["retval"]

    if "arguments" in result:
        for i, a in list(result["arguments"].items()):
            if "type" in a:
                a["type"] = calc_type(a["type"])

            for k in ("type_modifier", "sel_of_type"):
                if k in a:
                    if isinstance(a[k], (list, tuple)):
                        a[k] = sel32or64(a[k][0], a[k][1])
                    else:
                        a[k] = a[k]

            if "callable" in a:
                this_callable = a["callable"]
                for value in itertools.chain(
                    [this_callable.get("retval", {})],
                    this_callable.get("arguments", {}).values(),
                ):
                    if "type" not in value:
                        raise ValueError(
                            "Missing 'type' in argument/retval spec for %s %s"
                            % (infolist[0]["class"], infolist[0]["selector"])
                        )
                    if isinstance(value["type"], str):
                        value["type"] = value["type"]

                    elif isinstance(value["type"], WrappedCall):
                        pass

                    else:
                        value["type"] = sel32or64(value["type"][0], value["type"][1])

            if not a:
                del result["arguments"][i]
        if not result["arguments"]:
            del result["arguments"]

    if not result:
        return None

    return {
        "class": clsname,
        "selector": selector,
        "class_method": class_method,
        "metadata": result,
    }


def extract_method_info(exceptions, headerinfo, section="classes"):
    result = {}
    excinfo = exceptions["definitions"].get("classes", {})

    for info in headerinfo:
        for name, value in info["definitions"].get(section, {}).items():
            for meth in value.get("methods", ()):
                key = (name, meth["selector"], meth["class_method"])
                if key in result:
                    result[key].append(dict(meth))
                else:
                    result[key] = [dict(meth)]

                result[key][-1]["arch"] = info["arch"]
                result[key][-1]["class"] = name

            for prop in value.get("properties", ()):
                # Properties have a getter and optionally a setter method,
                # ensure that those are visible to the metadata system.
                getter = prop["name"]
                setter = "set" + getter[0].upper() + getter[1:] + ":"
                for item in prop.get("attributes", ()):
                    if item == "readonly":
                        setter = None
                    elif item[0] == "getter":
                        getter = item[1]
                    elif item[0] == "setter":
                        setter = item[1]

                if getter:
                    key = (name, getter, False)
                    meth = {
                        "selector": getter,
                        "retval": {
                            "typestr": prop["typestr"],
                            "typestr_special": prop["typestr_special"],
                        },
                        "args": [],
                        "class_method": False,
                    }
                    if key in result:
                        result[key].append(dict(meth))
                    else:
                        result[key] = [dict(meth)]
                    result[key][-1]["arch"] = info["arch"]
                    result[key][-1]["class"] = name

                if setter:
                    key = (name, setter, False)
                    meth = {
                        "selector": setter,
                        "retval": {"typestr": b"v", "typestr_special": False},
                        "args": [
                            {
                                "typestr": prop["typestr"],
                                "typestr_special": prop["typestr_special"],
                            }
                        ],
                        "class_method": False,
                    }
                    if key in result:
                        result[key].append(dict(meth))
                    else:
                        result[key] = [dict(meth)]
                    result[key][-1]["arch"] = info["arch"]
                    result[key][-1]["class"] = name

    for key in list(result):
        if section != "classes":
            use_key = ("NSObject",) + key[1:]
        else:
            use_key = key

        print(key[0], key[1], key[2])
        result[key] = merge_method_info(
            key[0],
            key[1],
            key[2],
            result[key],
            exception_method(excinfo, use_key),
            section == "classes",
        )

    if section == "classes":
        for clsname in excinfo:
            for meth in excinfo[clsname].get("methods", ()):
                key = (clsname, meth["selector"], meth["class_method"])
                if key in result:
                    continue

                result[key] = merge_method_info(
                    clsname,
                    meth["selector"],
                    meth["class_method"],
                    [],
                    meth,
                    section == "classes",
                )

    result = [info for info in result.values() if info is not None]
    if section != "classes":
        for item in result:
            item["class"] = "NSObject"

    return result


def extract_structs(exceptions, headerinfo):
    excinfo = exceptions["definitions"].get("structs", {})
    create_struct_type = FuncCall("objc.createStructType")
    register_struct_alias = FuncCall("objc.registerStructAlias")
    get_name = FuncCall("objc._resolve_name")

    structs = {}
    for info in headerinfo:
        for name, value in info["definitions"].get("structs", {}).items():
            if name in excinfo and excinfo[name].get("ignore", False):
                continue

            alias = None
            pack = None
            fieldnames = value["fieldnames"]
            if name in excinfo:
                fieldnames = [(x,) for x in excinfo[name].get("fieldnames", fieldnames)]
                alias = excinfo[name].get("alias", None)
                pack = excinfo[name].get("pack", None)

            if name not in structs:
                structs[name] = []

            structs[name].append(
                {
                    "typestr": value["typestr"],
                    "fieldnames": fieldnames,
                    "alias": alias,
                    "pack": pack,
                    "arch": info["arch"],
                }
            )

    result = {}
    for name, values in structs.items():
        fieldnames = values[0]["fieldnames"]
        for v in values:
            v["typestr"] = v["typestr"]
        print(name)
        typestr = merge_defs(values, "typestr")["typestr"]
        alias = values[0]["alias"]
        pack = values[0]["pack"]
        if fieldnames and isinstance(fieldnames[0], (list, tuple)):
            # fieldnames = sel32or64(*[map(str, names) for names in fieldnames])
            # fieldnames = map(str, fieldnames)
            fieldnames = [str(x[0]) for x in fieldnames]
        else:
            fieldnames = list(map(str, fieldnames))

        if alias is None:
            if pack is None:
                result[name] = create_struct_type(name, typestr, fieldnames)
            else:
                result[name] = create_struct_type(name, typestr, fieldnames, None, pack)
        else:
            result[name] = register_struct_alias(typestr, get_name(alias))

    return result


def emit_structs(fp, structs):
    if structs:
        print("misc.update(%r)" % (structs,), file=fp)


def emit_externs(fp, externs):
    result = []
    special = {}

    for k, v in sorted(externs.items()):
        if isinstance(v, dict):
            magic = v.get("magic_cookie", False)

            if v["typestr"] == "@":
                result.append(k)

            elif isinstance(v["typestr"], WrappedCall):
                special[k] = v["typestr"]
            else:
                result.append("%s@%s%s" % (k, "=" if magic else "", v["typestr"]))

        else:
            raise ValueError("manual mapping needed")

    fp.write("constants = '''$%s$'''\n" % ("$".join(result),))
    if special:
        for k, v in special.items():
            fp.write("constants = constants + '$%s@%%s$'%%(%r,)\n" % (k, v))


def emit_enums(fp, enums):
    result = []
    expr = {}
    for k, v in sorted(enums.items()):
        if isinstance(v, dict):
            if isinstance(v["value"], WrappedCall):
                expr[k] = v["value"]

            elif isinstance(v["value"], str):
                expr[k] = UStr(v["value"])

            else:
                result.append("%s@%s" % (k, v["value"]))

        elif isinstance(v, int):
            result.append("%s@%s" % (k, v))

        else:
            raise ValueError("manual mapping needed")

    fp.write("enums = '''$%s$'''\n" % ("$".join(result),))
    if expr:
        fp.write("misc.update(%r)\n" % (expr,))


def emit_method_info(fp, method_info):
    if method_info:
        fp.write("r = objc.registerMetaDataForSelector\n")
        fp.write("objc._updatingMetadata(True)\n")
        fp.write("try:\n")

        for record in sorted(method_info, key=operator.itemgetter("class", "selector")):
            fp.write(
                "    r(%r, %r, %r)\n"
                % (BStr(record["class"]), BStr(record["selector"]), record["metadata"])
            )

        fp.write("finally:\n")
        fp.write("    objc._updatingMetadata(False)\n")


def emit_informal_protocols(fp, protocol_info):
    if protocol_info:
        print("protocols=%r" % (protocol_info,), file=fp)


def emit_functions(fp, functions):
    if functions:
        print("functions=%r" % (functions,), file=fp)


def emit_cftypes(fp, cftypes):
    if cftypes:
        print("cftypes=%r" % (cftypes,), file=fp)


def emit_opaque(fp, opaque):
    if opaque:
        print("misc.update(%r)" % (opaque,), file=fp)


def extract_literal(exceptions, headerinfo):
    excinfo = exceptions["definitions"].get("literals", {})

    found = {}
    for info in headerinfo:
        for name, value in info["definitions"].get("literals", {}).items():
            if name in excinfo and excinfo[name].get("ignore", False):
                continue

            is_unicode = False
            if name in excinfo and excinfo[name].get("unicode", False):
                is_unicode = True

            if isinstance(value, dict):
                if value.get("unicode", False):
                    is_unicode = True

                if isinstance(value["value"], str):
                    if is_unicode:
                        value = UStr(value["value"])
                    else:
                        value = BStr(value["value"])

            else:
                if isinstance(value, str):
                    if is_unicode:
                        value = UStr(value)
                    else:
                        value = BStr(value)

            if name not in found:
                found[name] = []

            found[name].append({"value": value, "arch": info["arch"]})

    result = {}
    for k, v in found.items():
        v = merge_defs(v, "value")
        result[k] = v["value"]

    return result


def emit_literal(fp, literals):
    print("misc.update(%r)" % (literals,), file=fp)


def emit_expressions(fp, expressions):
    print("expressions = %r" % (expressions,), file=fp)


def emit_aliases(fp, aliases):
    if aliases:
        print("aliases = %r" % (aliases,), file=fp)


def compile_metadata(output_fn, exceptions_fn, headerinfo_fns):
    """
    Combine the data from header files scans and manual exceptions
    into a file than is usable for the metadata support in
    pyobjc 2.4 or later.
    """
    exceptions = load_framework_info(exceptions_fn)
    headerinfo = [load_framework_info(fn) for fn in headerinfo_fns]
    with open(output_fn, "w") as fp:
        fp.write(HEADER % {"timestamp": time.ctime()})

        emit_structs(fp, extract_structs(exceptions, headerinfo))
        emit_externs(fp, extract_externs(exceptions, headerinfo))
        emit_enums(fp, extract_enums(exceptions, headerinfo))
        emit_literal(fp, extract_literal(exceptions, headerinfo))
        emit_functions(fp, extract_functions(exceptions, headerinfo))
        emit_aliases(fp, extract_aliases(exceptions, headerinfo))
        emit_cftypes(fp, extract_cftypes(exceptions, headerinfo))
        emit_opaque(fp, extract_opaque_cftypes(exceptions, headerinfo))
        emit_opaque(fp, extract_opaque(exceptions))
        emit_method_info(fp, extract_method_info(exceptions, headerinfo))
        emit_method_info(
            fp, extract_method_info(exceptions, headerinfo, "formal_protocols")
        )
        emit_method_info(
            fp, extract_method_info(exceptions, headerinfo, "informal_protocols")
        )
        emit_informal_protocols(fp, extract_informal_protocols(exceptions, headerinfo))
        emit_expressions(fp, extract_expressions(exceptions, headerinfo))
        fp.write(FOOTER)
