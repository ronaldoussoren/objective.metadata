from __future__ import absolute_import

import collections
import os
import re
import textwrap
import time

from .compile import _is_32_bit, _is_64_bit
from .storage import load_framework_info


class MergeNeededException(Exception):
    pass


HEADER = textwrap.dedent(
    """\
    /*
     * This file is generated by objective.metadata
     *
     * Last update: %(timestamp)s
     */

    static void __attribute__((__used__)) use_protocols(void)
    {
        PyObject* p;
"""
)

FOOTER = textwrap.dedent(
    """\
    }
"""
)

FIND_VERSION = re.compile(r"MacOSX(\d+\.\d+)u?.sdk")


def classify_archs(archs):
    if _is_32_bit(archs):
        return "!defined(__LP64__)"

    if _is_64_bit(archs):
        print([(a, _is_32_bit(a)) for a in archs])
        return "defined(__LP64__)"

    return None


def classify_versions(versions):
    min_version = min(versions)
    if min_version == "10.6":
        return None

    return "PyObjC_BUILD_RELEASE >= %s" % (
        "%02d%02d" % (tuple(map(int, min_version.split("."))))
    )


def protocol_selector(found_info):
    versions_seen = {info[0] for info in found_info}
    archs_seen = {info[1] for info in found_info}

    selectors = []
    arch_selector = classify_archs(archs_seen)
    if arch_selector is not None:
        selectors.append(arch_selector)

    version_selector = classify_versions(versions_seen)
    if version_selector is not None:
        selectors.append(version_selector)

    if selectors:
        return " && ".join(selectors)

    return None


def compile_protocol_file(output_fn, exceptions_fn, headerinfo_fns):
    """
    Combine the data from header files scans and manual exceptions
    into a file than is usable for the metadata support in
    pyobjc 2.4 or later.
    """
    # exceptions = load_framework_info(exceptions_fn)
    headerinfo = [load_framework_info(fn) for fn in headerinfo_fns]

    if not os.path.exists(os.path.dirname(output_fn)):
        os.makedirs(os.path.dirname(output_fn))

    with open(output_fn, "w") as fp:
        fp.write(HEADER % {"timestamp": time.ctime()})

        protocols = collections.defaultdict(list)

        for info in headerinfo:
            sdk = FIND_VERSION.search(info["sdk"]).group(1)
            arch = info["arch"]

            for name in info["definitions"].get("formal_protocols", ()):
                protocols[name].append((sdk, arch))

        grouped_names = collections.defaultdict(list)

        for name in protocols:
            selector = protocol_selector(protocols[name])
            grouped_names[selector].append(name)

        for selector in sorted(grouped_names):
            if selector is not None:
                fp.write("#if %s\n" % (selector,))
            for nm in sorted(grouped_names[selector]):
                fp.write(
                    "    p = PyObjC_IdToPython(@protocol(%s)); Py_XDECREF(p);\n" % (nm,)
                )
            if selector is not None:
                fp.write("#endif /* %s */\n" % (selector,))

        fp.write(FOOTER)
